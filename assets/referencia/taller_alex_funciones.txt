-- ==========================================
--  WEB / APP CLIENTE, funciones taller_alex, base de datos
-- ==========================================

-- 1. Agendar cita
CREATE OR REPLACE FUNCTION taller_alex.agendar_cita(
    p_cliente_id uuid,
    p_vehiculo_id uuid,
    p_sucursal_id uuid,
    p_servicios uuid[],
    p_fecha timestamptz,
    p_notas text DEFAULT NULL
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_cita_id uuid;
    v_duracion_total int := 0;
    v_fin timestamptz;
BEGIN
    -- calcular duraci贸n total
    SELECT COALESCE(SUM(duracion_min),0)
    INTO v_duracion_total
    FROM taller_alex.servicios
    WHERE id = ANY(p_servicios);

    v_fin := p_fecha + (v_duracion_total || ' minutes')::interval;

    INSERT INTO taller_alex.citas (cliente_id, vehiculo_id, sucursal_id, inicio, fin, estado, notas_cliente)
    VALUES (p_cliente_id, p_vehiculo_id, p_sucursal_id, p_fecha, v_fin, 'pendiente', p_notas)
    RETURNING id INTO v_cita_id;

    -- insertar servicios de la cita
    INSERT INTO taller_alex.cita_servicios (cita_id, servicio_id, precio_aplicado)
    SELECT v_cita_id, s.id, s.precio_base
    FROM taller_alex.servicios s
    WHERE s.id = ANY(p_servicios);

    RETURN v_cita_id;
END;
$$;

-- 2. Cancelar cita
CREATE OR REPLACE FUNCTION taller_alex.cancelar_cita(
    p_cita_id uuid,
    p_cliente_id uuid
) RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE taller_alex.citas
    SET estado = 'cancelada'
    WHERE id = p_cita_id AND cliente_id = p_cliente_id;
END;
$$;

-- 3. Consultar estado de veh铆culo (usa 煤ltima orden)
CREATE OR REPLACE FUNCTION taller_alex.estado_vehiculo(
    p_vehiculo_id uuid
) RETURNS TABLE(
    orden_id uuid,
    estado text,
    fecha_inicio timestamptz,
    fecha_fin_estimada timestamptz,
    fecha_fin_real timestamptz
)
LANGUAGE sql
AS $$
    SELECT os.id, os.estado, os.fecha_inicio, os.fecha_fin_estimada, os.fecha_fin_real
    FROM taller_alex.ordenes_servicio os
    JOIN taller_alex.citas c ON c.id = os.cita_id
    WHERE c.vehiculo_id = p_vehiculo_id
    ORDER BY os.fecha_inicio DESC
    LIMIT 1;
$$;


-- ==========================================
--  APP DEL TCNICO
-- ==========================================

-- 4. Tomar asignaci贸n de una cita
CREATE OR REPLACE FUNCTION taller_alex.tomar_asignacion(
    p_empleado_id uuid,
    p_cita_id uuid,
    p_rol taller_alex.rol_asignacion DEFAULT 'responsable'
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_asignacion_id uuid;
BEGIN
    INSERT INTO taller_alex.asignaciones_tecnico (cita_id, empleado_id, rol)
    VALUES (p_cita_id, p_empleado_id, p_rol)
    RETURNING id INTO v_asignacion_id;

    RETURN v_asignacion_id;
END;
$$;

-- 5. Iniciar/terminar tarea de servicio
CREATE OR REPLACE FUNCTION taller_alex.registrar_tiempo(
    p_orden_item_id uuid,
    p_empleado_id uuid,
    p_accion text
) RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    IF p_accion = 'iniciar' THEN
        INSERT INTO taller_alex.tiempos_tecnico (orden_item_id, empleado_id, inicio)
        VALUES (p_orden_item_id, p_empleado_id, now());
    ELSIF p_accion = 'terminar' THEN
        UPDATE taller_alex.tiempos_tecnico
        SET fin = now(), minutos = EXTRACT(EPOCH FROM (now()-inicio))/60
        WHERE orden_item_id = p_orden_item_id
          AND empleado_id = p_empleado_id
          AND fin IS NULL;
    END IF;
END;
$$;

-- 6. Subir evidencia (foto)
CREATE OR REPLACE FUNCTION taller_alex.subir_evidencia(
    p_orden_id uuid,
    p_archivo_id uuid,
    p_etiqueta taller_alex.etiqueta_adjuntos_orden
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_id uuid;
BEGIN
    INSERT INTO taller_alex.adjuntos_orden (orden_id, archivo_id, etiqueta)
    VALUES (p_orden_id, p_archivo_id, p_etiqueta)
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;


-- ==========================================
--  CRM / ADMINISTRACIN
-- ==========================================

-- 7. Crear orden desde cita
CREATE OR REPLACE FUNCTION taller_alex.crear_orden_desde_cita(
    p_cita_id uuid,
    p_empleado_id uuid
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_orden_id uuid;
BEGIN
    INSERT INTO taller_alex.ordenes_servicio (cita_id, empleado_responsable_id, estado, fecha_inicio)
    VALUES (p_cita_id, p_empleado_id, 'creada', now())
    RETURNING id INTO v_orden_id;

    INSERT INTO taller_alex.orden_items_servicio (orden_id, servicio_id, descripcion, precio_unitario, cantidad, subtotal)
    SELECT v_orden_id, cs.servicio_id, s.descripcion, cs.precio_aplicado, 1, cs.precio_aplicado
    FROM taller_alex.cita_servicios cs
    JOIN taller_alex.servicios s ON s.id = cs.servicio_id
    WHERE cs.cita_id = p_cita_id;

    RETURN v_orden_id;
END;
$$;

-- 8. Cerrar orden de servicio
CREATE OR REPLACE FUNCTION taller_alex.cerrar_orden(
    p_orden_id uuid,
    p_empleado_id uuid
) RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE taller_alex.ordenes_servicio
    SET estado = 'cerrada', fecha_fin_real = now()
    WHERE id = p_orden_id;

    -- opcional: insertar en bit谩cora
    INSERT INTO taller_alex.bitacora_eventos (actor_usuario_id, entidad, entidad_id, accion, datos)
    VALUES (p_empleado_id, 'ordenes_servicio', p_orden_id, 'CERRAR', '{}'::jsonb);
END;
$$;

-- 9. Registrar pago
CREATE OR REPLACE FUNCTION taller_alex.registrar_pago(
    p_orden_id uuid,
    p_cliente_id uuid,
    p_monto numeric,
    p_metodo taller_alex.metodo_pago,
    p_sucursal_id uuid
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_pago_id uuid;
BEGIN
    INSERT INTO taller_alex.pagos (orden_id, cliente_id, monto, metodo, estado, fecha_pago, sucursal_id)
    VALUES (p_orden_id, p_cliente_id, p_monto, p_metodo, 'pagado', now(), p_sucursal_id)
    RETURNING id INTO v_pago_id;

    RETURN v_pago_id;
END;
$$;

-- 10. Emitir factura
CREATE OR REPLACE FUNCTION taller_alex.emitir_factura(
    p_pago_id uuid,
    p_folio text,
    p_pdf_url text,
    p_xml_url text,
    p_sucursal_id uuid
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_factura_id uuid;
BEGIN
    INSERT INTO taller_alex.facturas (pago_id, folio, fecha_emision, pdf_url, xml_url, sucursal_id)
    VALUES (p_pago_id, p_folio, now(), p_pdf_url, p_xml_url, p_sucursal_id)
    RETURNING id INTO v_factura_id;

    RETURN v_factura_id;
END;
$$;

-- 11. Funci贸n RPC parametrizable (ideal para filtros en el dashboard)


CREATE OR REPLACE FUNCTION taller_alex.get_dashboard_sucursal(
  p_sucursal_id uuid,
  p_inicio date DEFAULT current_date,
  p_fin date   DEFAULT current_date
)
RETURNS TABLE(
  sucursal_id uuid,
  sucursal_nombre text,
  citas_total int,
  citas_pendientes int,
  citas_no_asistio int,
  ordenes_abiertas int,
  ordenes_cerradas int,
  ingresos_total numeric,
  bahias_totales int,
  bahias_ocupadas int,
  refacciones_alerta int
)
LANGUAGE sql
AS $$
  WITH base AS (
    SELECT s.id, s.nombre
    FROM taller_alex.sucursales s
    WHERE s.id = p_sucursal_id
  )
  SELECT
    b.id,
    b.nombre,
    -- Citas en rango
    COUNT(DISTINCT c.id) FILTER (WHERE c.inicio::date BETWEEN p_inicio AND p_fin)                                   AS citas_total,
    COUNT(DISTINCT c.id) FILTER (WHERE c.inicio::date BETWEEN p_inicio AND p_fin AND c.estado='pendiente')          AS citas_pendientes,
    COUNT(DISTINCT c.id) FILTER (WHERE c.inicio::date BETWEEN p_inicio AND p_fin AND c.estado='no_asistio')         AS citas_no_asistio,
    -- rdenes
    COUNT(DISTINCT os.id) FILTER (WHERE os.estado NOT IN ('cerrada','cancelada','entregada'))                       AS ordenes_abiertas,
    COUNT(DISTINCT os.id) FILTER (WHERE os.estado IN ('cerrada','entregada') AND os.fecha_fin_real::date BETWEEN p_inicio AND p_fin) AS ordenes_cerradas,
    -- Ingresos
    COALESCE(SUM(p.monto) FILTER (WHERE p.estado='pagado' AND p.fecha_pago::date BETWEEN p_inicio AND p_fin),0)     AS ingresos_total,
    -- Bah铆as
    COUNT(DISTINCT bt.id)                                                                                            AS bahias_totales,
    COUNT(DISTINCT ab.id) FILTER (WHERE ab.inicio::date BETWEEN p_inicio AND p_fin)                                  AS bahias_ocupadas,
    -- Inventario
    COUNT(ir.id) FILTER (WHERE ir.existencias <= ir.minimo_alerta)                                                   AS refacciones_alerta
  FROM base b
  LEFT JOIN taller_alex.citas c                 ON c.sucursal_id = b.id
  LEFT JOIN taller_alex.ordenes_servicio os     ON os.cita_id = c.id
  LEFT JOIN taller_alex.pagos p                 ON p.sucursal_id = b.id
  LEFT JOIN taller_alex.bahias_trabajo bt       ON bt.sucursal_id = b.id
  LEFT JOIN taller_alex.agenda_bahias ab        ON ab.bahia_id = bt.id
  LEFT JOIN taller_alex.inventario_refacciones ir ON ir.sucursal_id = b.id
  GROUP BY b.id, b.nombre;
$$;

-- 11. Funci贸n RPC reservar_bahia

CREATE OR REPLACE FUNCTION taller_alex.reservar_bahia(
  p_cita_id uuid,
  p_bahia_id uuid,
  p_inicio timestamptz,
  p_fin timestamptz
) RETURNS uuid
LANGUAGE plpgsql AS $$
DECLARE v_id uuid;
BEGIN
  IF p_fin <= p_inicio THEN
    RAISE EXCEPTION 'Fin debe ser mayor a inicio';
  END IF;

  -- No solape en la misma bah铆a
  IF EXISTS (
    SELECT 1 FROM taller_alex.agenda_bahias ab
    WHERE ab.bahia_id = p_bahia_id
      AND tstzrange(ab.inicio, ab.fin, '[)') && tstzrange(p_inicio, p_fin, '[)')
  ) THEN
    RAISE EXCEPTION 'La bah铆a ya est谩 ocupada en ese horario';
  END IF;

  INSERT INTO taller_alex.agenda_bahias (id, bahia_id, cita_id, inicio, fin)
  VALUES (gen_random_uuid(), p_bahia_id, p_cita_id, p_inicio, p_fin)
  RETURNING id INTO v_id;

  RETURN v_id;
END; $$;


-- 12. get_empleados_sucursal --

CREATE OR REPLACE FUNCTION taller_alex.get_empleados_sucursal(
  p_sucursal_id uuid,
  p_inicio date DEFAULT current_date,
  p_fin date   DEFAULT current_date
)
RETURNS TABLE(
  empleado_id uuid,
  empleado_nombre text,
  puesto taller_alex.puesto_empleado,
  activo boolean,
  en_turno_now boolean,
  turno_inicio timestamptz,
  turno_fin timestamptz,
  minutos_periodo int,
  ordenes_abiertas int
)
LANGUAGE sql
AS $$
WITH turno_now AS (
  SELECT t.empleado_id, TRUE en_turno_now, t.inicio, t.fin
  FROM taller_alex.turnos_empleado t
  WHERE now() BETWEEN t.inicio AND t.fin
),
base AS (
  SELECT e.id AS empleado_id, u.nombre || ' ' || u.apellido AS empleado_nombre,
         e.puesto, e.activo
  FROM taller_alex.empleados e
  JOIN taller_alex.usuarios u ON u.id = e.usuario_id
  JOIN taller_alex.empleados_sucursales es ON es.empleado_id = e.id AND es.activo = TRUE
  WHERE es.sucursal_id = p_sucursal_id
),
mins AS (
  SELECT tt.empleado_id, COALESCE(SUM(tt.minutos),0)::int AS minutos_periodo
  FROM taller_alex.tiempos_tecnico tt
  WHERE tt.inicio::date BETWEEN p_inicio AND p_fin
  GROUP BY tt.empleado_id
),
ords AS (
  SELECT e.id AS empleado_id,
         COUNT(DISTINCT os.id) FILTER (WHERE os.estado NOT IN ('cerrada','cancelada','entregada')) AS ordenes_abiertas
  FROM taller_alex.empleados e
  JOIN taller_alex.tiempos_tecnico tt ON tt.empleado_id = e.id
  JOIN taller_alex.orden_items_servicio oi ON oi.id = tt.orden_item_id
  JOIN taller_alex.ordenes_servicio os ON os.id = oi.orden_id
  JOIN taller_alex.citas c ON c.id = os.cita_id
  WHERE c.sucursal_id = p_sucursal_id
  GROUP BY e.id
)
SELECT
  b.empleado_id,
  b.empleado_nombre,
  b.puesto,
  b.activo,
  COALESCE(tn.en_turno_now, FALSE) AS en_turno_now,
  tn.inicio AS turno_inicio,
  tn.fin    AS turno_fin,
  COALESCE(m.minutos_periodo,0)    AS minutos_periodo,
  COALESCE(o.ordenes_abiertas,0)   AS ordenes_abiertas
FROM base b
LEFT JOIN turno_now tn ON tn.empleado_id = b.empleado_id
LEFT JOIN mins m       ON m.empleado_id  = b.empleado_id
LEFT JOIN ords o       ON o.empleado_id  = b.empleado_id
ORDER BY b.empleado_nombre;
$$;


-- 13. programar_turno_empleado --

CREATE OR REPLACE FUNCTION taller_alex.programar_turno_empleado(
  p_empleado_id uuid,
  p_sucursal_id uuid,
  p_inicio timestamptz,
  p_fin timestamptz,
  p_tipo taller_alex.tipo_turno_empleado DEFAULT 'normal'
) RETURNS uuid
LANGUAGE plpgsql AS $$
DECLARE v_id uuid;
BEGIN
  IF p_fin <= p_inicio THEN
    RAISE EXCEPTION 'Fin debe ser mayor a inicio';
  END IF;

  -- (Opcional) Verificar que pertenece a la sucursal
  IF NOT EXISTS (
    SELECT 1 FROM taller_alex.empleados_sucursales
    WHERE empleado_id = p_empleado_id AND sucursal_id = p_sucursal_id AND activo = TRUE
  ) THEN
    PERFORM taller_alex.asignar_empleado_a_sucursal(p_empleado_id, p_sucursal_id);
  END IF;

  INSERT INTO taller_alex.turnos_empleado (id, empleado_id, sucursal_id, inicio, fin, tipo)
  VALUES (gen_random_uuid(), p_empleado_id, p_sucursal_id, p_inicio, p_fin, p_tipo)
  RETURNING id INTO v_id;

  RETURN v_id;
END; $$;




-- 1. Funci贸n para mover empleado entre sucursales
CREATE OR REPLACE FUNCTION taller_alex.mover_empleado_sucursal(
  p_empleado_id uuid,
  p_nueva_sucursal_id uuid
) RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  -- Cerrar asignaci贸n previa
  UPDATE taller_alex.empleados_sucursales
  SET activo = FALSE, fecha_fin = current_date
  WHERE empleado_id = p_empleado_id AND activo = TRUE;

  -- Asignar a nueva sucursal
  PERFORM taller_alex.asignar_empleado_a_sucursal(p_empleado_id, p_nueva_sucursal_id);
END;
$$;

-- 2. Funci贸n para cambiar rol de empleado
CREATE OR REPLACE FUNCTION taller_alex.cambiar_rol_empleado(
  p_usuario_id uuid,
  p_role_id bigint
) RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE public.user_profile
  SET role_fk = p_role_id,
      updated_at = now()
  WHERE user_profile_id = p_usuario_id
    AND organization_fk = 11;
END;
$$;